"""Tests for runway.cfngin.hooks.base."""
# pylint: disable=no-self-use
import logging

import pytest
from mock import MagicMock, patch

from runway.cfngin.hooks.base import Hook
from runway.cfngin.status import COMPLETE, FAILED, SKIPPED, SUBMITTED


class TestHook(object):
    """Tests for Tests for runway.cfngin.hooks.base.Hook."""

    def test_attributes(self, cfngin_context):
        """Test attributes set during __init__."""
        provider = MagicMock()
        args = {
            'key': 'val'
        }
        result = Hook(cfngin_context, provider, **args)

        assert result.args.key == 'val'
        assert result.args.tags == {}
        assert not result.blueprint
        assert result.context == cfngin_context
        assert result.provider == provider
        assert not result.stack
        assert result.stack_name == 'stack'

    def test_tags(self, cfngin_context):
        """Test tags property."""
        cfngin_context.config['tags'] = {'context_tag': 'val'}

        hook = Hook(cfngin_context, MagicMock(), **{'tags': {'arg_tag': 'val'}})

        assert hook.tags.to_dict() == [{'Key': 'arg_tag', 'Value': 'val'},
                                       {'Key': 'context_tag', 'Value': 'val'}]

    def test_get_template_description(self, cfngin_context):
        """Test for get_template_description."""
        hook = Hook(cfngin_context, MagicMock())

        result = hook.get_template_description()

        assert result == 'Automatically generated by {}'.format(
            hook.__class__.__module__
        )
        assert hook.get_template_description('suffix').endswith(' - suffix')

    @patch('runway.cfngin.hooks.base.HookBuildAction.run',
           MagicMock(return_value=COMPLETE))
    def test_deploy_stack(self, cfngin_context, caplog):
        """Test for deploy_stack."""
        hook = Hook(cfngin_context, MagicMock())
        stack = MagicMock()
        stack.name = 'test-stack'

        with caplog.at_level(logging.INFO, logger='runway.cfngin.hooks.base'):
            assert hook.deploy_stack(stack=stack, wait=False) == COMPLETE

        assert caplog.records[0].message == '%s: %s' % (stack.name,
                                                        COMPLETE.name)

    @patch('runway.cfngin.hooks.base.HookBuildAction.run',
           MagicMock(side_effect=[SUBMITTED, COMPLETE]))
    def test_deploy_stack_wait(self, cfngin_context, caplog):
        """Test for deploy_stack with wait."""
        hook = Hook(cfngin_context, MagicMock())
        stack = MagicMock()
        stack.name = 'test-stack'

        with caplog.at_level(logging.INFO, logger='runway.cfngin.hooks.base'):
            assert hook.deploy_stack(stack=stack, wait=True) == COMPLETE

        assert caplog.records[0].message == '%s: %s' % (stack.name,
                                                        SUBMITTED.name)
        assert caplog.records[1].message == 'Waiting for stack to complete...'
        assert caplog.records[2].message == '%s: %s' % (stack.name,
                                                        COMPLETE.name)

    @patch('runway.cfngin.hooks.base.HookBuildAction.run',
           MagicMock(side_effect=[SKIPPED]))
    def test_deploy_stack_wait_skipped(self, cfngin_context, caplog):
        """Test for deploy_stack with wait and skip."""
        hook = Hook(cfngin_context, MagicMock())
        stack = MagicMock()
        stack.name = 'test-stack'

        with caplog.at_level(logging.INFO, logger='runway.cfngin.hooks.base'):
            assert hook.deploy_stack(stack=stack, wait=True) == SKIPPED

        assert caplog.records[0].message == '%s: %s' % (stack.name,
                                                        SKIPPED.name)

    @patch('runway.cfngin.hooks.base.HookBuildAction.run',
           MagicMock(side_effect=[FAILED]))
    def test_deploy_stack_wait_failed(self, cfngin_context, caplog):
        """Test for deploy_stack with wait and skip."""
        hook = Hook(cfngin_context, MagicMock())
        stack = MagicMock()
        stack.name = 'test-stack'

        with caplog.at_level(logging.INFO, logger='runway.cfngin.hooks.base'):
            assert hook.deploy_stack(stack=stack, wait=True) == FAILED

        assert caplog.records[0].message == '%s: %s' % (stack.name,
                                                        FAILED.name)

    @patch('runway.cfngin.hooks.base.HookDestroyAction.run',
           MagicMock(side_effect=[SUBMITTED, COMPLETE]))
    def test_destroy_stack(self, cfngin_context, caplog):
        """Test for destroy_stack with wait."""
        hook = Hook(cfngin_context, MagicMock())
        stack = MagicMock()
        stack.name = 'test-stack'

        with caplog.at_level(logging.INFO, logger='runway.cfngin.hooks.base'):
            assert hook.destroy_stack(stack=stack, wait=True) == COMPLETE

        assert caplog.records[0].message == '%s: %s' % (stack.name,
                                                        SUBMITTED.name)
        assert caplog.records[1].message == 'Waiting for stack to complete...'
        assert caplog.records[2].message == '%s: %s' % (stack.name,
                                                        COMPLETE.name)

    def test_post_deploy(self, cfngin_context):
        """Test post_deploy."""
        hook = Hook(cfngin_context, MagicMock())

        with pytest.raises(NotImplementedError):
            hook.post_deploy()

    def test_post_destroy(self, cfngin_context):
        """Test post_destroy."""
        hook = Hook(cfngin_context, MagicMock())

        with pytest.raises(NotImplementedError):
            hook.post_destroy()

    def test_pre_deploy(self, cfngin_context):
        """Test pre_deploy."""
        hook = Hook(cfngin_context, MagicMock())

        with pytest.raises(NotImplementedError):
            hook.pre_deploy()

    def test_pre_destroy(self, cfngin_context):
        """Test pre_destroy."""
        hook = Hook(cfngin_context, MagicMock())

        with pytest.raises(NotImplementedError):
            hook.pre_destroy()
