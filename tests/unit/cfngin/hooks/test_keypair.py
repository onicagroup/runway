"""Tests for runway.cfngin.hooks.keypair."""
# pylint: disable=redefined-outer-name
from __future__ import annotations

import sys
from collections import namedtuple
from contextlib import contextmanager
from typing import TYPE_CHECKING, Iterator, Tuple

import boto3
import mock
import pytest
from moto import mock_ec2, mock_ssm

from runway.cfngin.hooks.keypair import KeyPairInfo, ensure_keypair_exists

from ..factories import mock_context

if TYPE_CHECKING:
    from pathlib import Path

    from runway.cfngin.context import Context

REGION = "us-east-1"
KEY_PAIR_NAME = "FakeKey"

SSHKey = namedtuple("SSHKey", "public_key private_key fingerprint")


@pytest.fixture(scope="module")
def ssh_key(cfngin_fixtures: Path) -> SSHKey:
    """Return an ssh key."""
    base = cfngin_fixtures / "keypair"
    return SSHKey(
        private_key=(base / "id_rsa").read_bytes(),
        public_key=(base / "id_rsa.pub").read_bytes(),
        fingerprint=(base / "fingerprint").read_text("ascii").strip(),
    )


@pytest.fixture
def context() -> Context:
    """Mock context."""
    return mock_context(namespace="fake")


@pytest.fixture(autouse=True)
def ec2(ssh_key: SSHKey) -> Iterator[None]:
    """Mock EC2."""
    # Force moto to generate a deterministic key pair on creation.
    # Can be replaced by something more sensible when
    # https://github.com/spulec/moto/pull/2108 is merged

    key_pair = {
        "fingerprint": ssh_key.fingerprint,
        "material": ssh_key.private_key.decode("ascii"),
    }
    with mock.patch("moto.ec2.models.random_key_pair", side_effect=[key_pair]):
        with mock_ec2():
            yield


@pytest.fixture(autouse=True)
def ssm() -> Iterator[None]:
    """Mock SSM."""
    with mock_ssm():
        yield


@contextmanager
def mock_input(
    lines: Tuple[str, ...] = (), isatty: bool = True
) -> Iterator[mock.MagicMock]:
    """Mock input."""
    with mock.patch(
        "runway.cfngin.hooks.keypair.get_raw_input", side_effect=lines
    ) as mock_get_raw_input:
        with mock.patch.object(sys.stdin, "isatty", return_value=isatty):
            yield mock_get_raw_input


def assert_key_present(
    hook_result: KeyPairInfo, key_name: str, fingerprint: str
) -> None:
    """Assert key present."""
    assert hook_result["key_name"] == key_name
    assert hook_result["fingerprint"] == fingerprint

    ec2 = boto3.client("ec2")
    response = ec2.describe_key_pairs(KeyNames=[key_name], DryRun=False)
    key_pairs = response["KeyPairs"]

    assert len(key_pairs) == 1
    assert key_pairs[0]["KeyName"] == key_name
    assert key_pairs[0]["KeyFingerprint"] == fingerprint


def test_param_validation(context: Context) -> None:
    """Test param validation."""
    result = ensure_keypair_exists(
        context,
        keypair=KEY_PAIR_NAME,
        ssm_parameter_name="test",
        public_key_path="test",
    )
    assert result == {}


def test_keypair_exists(context: Context) -> None:
    """Test keypair exists."""
    ec2 = boto3.client("ec2")
    keypair = ec2.create_key_pair(KeyName=KEY_PAIR_NAME)

    result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)
    expected = dict(
        status="exists", key_name=KEY_PAIR_NAME, fingerprint=keypair["KeyFingerprint"]
    )
    assert result == expected


def test_import_file(tmp_path: Path, context: Context, ssh_key: SSHKey) -> None:
    """Test import file."""
    pub_key = tmp_path / "id_rsa.pub"
    pub_key.write_bytes(ssh_key.public_key)

    result = ensure_keypair_exists(
        context, keypair=KEY_PAIR_NAME, public_key_path=str(pub_key)
    )
    assert_key_present(result, KEY_PAIR_NAME, ssh_key.fingerprint)
    assert result["status"] == "imported"


def test_import_bad_key_data(tmp_path: Path, context: Context) -> None:
    """Test import bad key data."""
    pub_key = tmp_path / "id_rsa.pub"
    pub_key.write_text("garbage")

    result = ensure_keypair_exists(
        context, keypair=KEY_PAIR_NAME, public_key_path=str(pub_key)
    )
    assert result == {}


@pytest.mark.parametrize("ssm_key_id", ["my-key"])
def test_create_in_ssm(context: Context, ssh_key: SSHKey, ssm_key_id: str) -> None:
    """Test create in ssm."""
    result = ensure_keypair_exists(
        context,
        keypair=KEY_PAIR_NAME,
        ssm_parameter_name="param",
        ssm_key_id=ssm_key_id,
    )

    assert_key_present(result, KEY_PAIR_NAME, ssh_key.fingerprint)
    assert result["status"] == "created"

    ssm = boto3.client("ssm")
    param = ssm.get_parameter(Name="param", WithDecryption=True)["Parameter"]
    assert param["Value"] == ssh_key.private_key.decode("ascii")
    assert param["Type"] == "SecureString"

    params = ssm.describe_parameters()["Parameters"]
    param_details = next(p for p in params if p["Name"] == "param")
    assert param_details[
        "Description"
    ] == 'SSH private key for KeyPair "{}" (generated by Runway)'.format(KEY_PAIR_NAME)
    assert param_details.get("KeyId") == ssm_key_id


def test_interactive_non_terminal_input(context: Context) -> None:
    """Test interactive non terminal input."""
    with mock_input(isatty=False) as _input:
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)
        _input.assert_not_called()
    assert result == {}


def test_interactive_retry_cancel(context: Context) -> None:
    """Test interactive retry cancel."""
    lines = ["garbage", "cancel"]
    with mock_input(lines) as _input:
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)
        assert _input.call_count == 2
    assert result == {}


def test_interactive_import(tmp_path: Path, context: Context, ssh_key: SSHKey) -> None:
    """."""
    key_file = tmp_path / "id_rsa.pub"
    key_file.write_bytes(ssh_key.public_key)

    lines = ["import", str(key_file)]
    with mock_input(lines):
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)

    assert_key_present(result, KEY_PAIR_NAME, ssh_key.fingerprint)
    assert result["status"] == "imported"


def test_interactive_create(tmp_path: Path, context: Context, ssh_key: SSHKey) -> None:
    """Test interactive create."""
    key_dir = tmp_path / "keys"
    key_dir.mkdir(parents=True, exist_ok=True)
    key_file = key_dir / f"{KEY_PAIR_NAME}.pem"

    lines = ["create", str(key_dir)]
    with mock_input(lines):
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)

    assert_key_present(result, KEY_PAIR_NAME, ssh_key.fingerprint)
    assert result["status"] == "created"
    assert key_file.samefile(result["file_path"])
    assert key_file.read_bytes() == ssh_key.private_key


def test_interactive_create_bad_dir(tmp_path: Path, context: Context) -> None:
    """Test interactive create bad dir."""
    key_dir = tmp_path / "missing"

    lines = ["create", str(key_dir)]
    with mock_input(lines):
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)

    assert result == {}


def test_interactive_create_existing_file(tmp_path: Path, context: Context) -> None:
    """Test interactive create existing file."""
    key_dir = tmp_path / "keys"
    key_dir.mkdir(exist_ok=True, parents=True)
    key_file = key_dir / f"{KEY_PAIR_NAME}.pem"
    key_file.touch()

    lines = ["create", str(key_dir)]
    with mock_input(lines):
        result = ensure_keypair_exists(context, keypair=KEY_PAIR_NAME)

    assert result == {}
