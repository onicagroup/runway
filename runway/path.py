"""Runway configuration 'path' settings."""
import logging
import os
import pathlib
from typing import Dict, Tuple, Union

from .config.models.runway import RunwayModuleDefinitionModel
from .constants import DEFAULT_CACHE_DIR
from .sources.git import Git

LOGGER = logging.getLogger(__name__)


class Path:
    """Runway configuration ``path`` settings object.

    Path is responsible for parsing the ``path`` property of a Runway
    configuration. It then can determine if the path specified is
    locally sourced or remotely sourced through a service such
    as `Git`_ or S3.

    Local ``path`` variables are defined relative to the root project folder.
    The value for this cannot be higher than the Runway config file, it must
    be at the runway file itself or in a sub directory.

    Example:
        .. code-block:: yaml

            deployments:
            - modules:
                - path: my/local/module.cfn
                - my/local/module.cfn # same as above
                - ./ # module is in the root

    When the ``path`` is remote, Runway is responsible for fetching
    the resource and returning the location of it's cached path.
    The information for retrieving those sources can be controlled via
    runway rather than manually retrieving each one.

    Example:
        .. code-block:: yaml

            deployments:
            - modules:
                - path: git::git://github.com/your_handle/your_repo.git//my-module.cfn


    The ``path`` structure is based on the
    encoding found in
    `Terraform modules <https://www.terraform.io/docs/modules/sources.html>`_.

    The values parsed from the string are as follows:

    .. rubric:: source

    Determine if the source is local or remote. The initial
    prefix is used to determine this separated by `::` in the string.
    A path is considered local if it contains no source type value.

    Example:
        .. code-block:: yaml

            deployments:
                - modules:
                    # source is `git`
                    - path: git::git://github.com/foo/bar.git

    .. rubric:: uri

    The uniform resource identifier when targetting a remote resource.
    This instructs runway on where to retrieve your module.

    Example:
        .. code-block:: yaml

            deployments:
                - modules:
                    # uri is `git://github.com/foo/bar.git`
                    - path: git::git://github.com/foo/bar.git

    .. rubric:: location

    The relative location of the module files from the root
    directory. This value is specified as a path after the uri separated
    by `//`

    Example:
        .. code-block:: yaml

            deployments:
                - modules:
                    # location is `my/path`
                    - path: git::git://github.com/foo/bar.git//my/path

    .. rubric:: options

    The remaining options that are passed along to the
    Source. This is specified in the path following the `?` separator.
    Multiple option keys and values can be specified with the `&` as
    the separator. Each remote source can have different options for
    retrieval, please make sure to review individual source types
    to get more information on properly formatting.

    Example:
        .. code-block:: yaml

            deployments:
                - modules:
                    # options are `foo=bar&ba=bop`
                    - path: git::git://github.com/foo/bar.git//my/path?foo=bar&baz=bop

    """

    def __init__(
        self,
        module: RunwayModuleDefinitionModel,
        env_root: pathlib.Path,
        cache_dir: pathlib.Path = DEFAULT_CACHE_DIR,
    ) -> None:
        """Path Configuration.

        Args:
            module: The module manifest or a string representation of a local path
                to a module.
            env_root: The current environments root directory path string.
            cache_dir: When a remote resource is requested it's Source object
                requires a cache directory to store it's request.
                This allows for an override of that default directory.

        """
        self.env_root = env_root
        self.cache_dir = cache_dir

        self.source, self.uri, self.location, self.options = self.parse(
            module
            if isinstance(module, RunwayModuleDefinitionModel)
            else RunwayModuleDefinitionModel(path=module)
        )
        self.module_root = self.__get_module_root_dir()

    def __get_module_root_dir(self) -> pathlib.Path:
        """Get module root directory.

        Retrieve the specific path location of the module. This can be static
        or dynamically generated by a remote resource Source object.

        """
        if self.location in [".", "." + os.sep]:
            return self.env_root
        if self.source != "local":
            return self.__fetch_remote_source()
        return self.env_root / self.location

    def __fetch_remote_source(self) -> pathlib.Path:
        """Switch based on the retrieved source of the path.

        Determine which remote Source type to fetch based on the source
        specified in the path variable.

        """
        if self.source == "git":
            return Git(**self.configuration).fetch()
        raise NotImplementedError(f"{self.source} is not a supported remove source")

    @property
    def configuration(self) -> Dict[str, Union[Dict[str, str], pathlib.Path, str]]:
        """Transform object into configuration settings for remote Sources."""
        return {
            "source": self.source,
            "location": self.location,
            "uri": self.uri,
            "options": self.options,
            "cache_dir": self.cache_dir,
        }

    @classmethod
    def parse(
        cls, module: RunwayModuleDefinitionModel
    ) -> Tuple[str, str, str, Dict[str, str]]:
        """Retrieve the relevant elements of the path variable passed.

        Given a dictionary with a `path` parameter parse the value into
        it's specific components. The path structure is based on the
        encoding found in
        `Terraform modules <https://www.terraform.io/docs/modules/sources.html>`_.

        Args:
            module: The module manifest or a string representation of a local
                path to a module.

        """
        if isinstance(module.path, pathlib.Path):
            return "local", "", module.path.name, {}
        if not module.path:
            return "local", "", "", {}

        split_source_location = str(module.path).split("::")

        # Local path
        if len(split_source_location) != 2:
            location = split_source_location[0]
            options = {}
            return "local", "", location, options

        location, options = cls.__parse_location_and_options(split_source_location[1])
        uri, location = cls.__parse_uri_and_location(location)

        return split_source_location[0], uri, location, options

    @classmethod
    def __parse_uri_and_location(cls, uri_loc_str: str) -> Tuple[str, str]:
        """Given a string extract the uri and remaining location values.

        Separator used is `//`. It is expected the uri will contain a
        protocol reference, so if a remote uri is used those values
        will be concatenated together.

        Args:
            uri_loc_str: The string that represents the uri and remaining
                location values.

        """
        split_uri_location = uri_loc_str.split("//")
        location_string = ""

        if len(split_uri_location) == 3:
            location_string = split_uri_location[2]

        return (
            "//".join([split_uri_location[0], split_uri_location[1]]),
            location_string,
        )

    @classmethod
    def __parse_location_and_options(
        cls, loc_opt_str: str
    ) -> Tuple[str, Dict[str, str]]:
        """Given a location string extract the location variable and the remote module options.

        Seperator used is `?`. Each of the options retrieved are then
        turned into a Dict for easy accessibility based on the `&` separator.

        Args:
            loc_opt_str: The string that represents the location
                and remaining option values.

        """
        split_location_options = loc_opt_str.split("?")
        location = split_location_options[0]
        options = {}

        if len(split_location_options) == 2:
            options = cls.__parse_options_dict(split_location_options[1])

        return location, options

    @staticmethod
    def __parse_options_dict(options_str: str) -> Dict[str, str]:
        """Convert the options string into a dict.

        Args:
            options_str (str): The options string that will
                be seperated into a dictionary based on the
                `&` separator.

        """
        opts = options_str.split("&")
        res = {}
        for opt in opts:
            key, value = opt.split("=")
            res[key] = value
        return res
