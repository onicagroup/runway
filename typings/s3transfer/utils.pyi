"""This type stub file was generated by pyright."""

from __future__ import annotations

from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    ClassVar,
    Dict,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
)

from typing_extensions import TypedDict

if TYPE_CHECKING:
    from logging import Logger
    from pathlib import Path

    from .futures import TransferFuture

_K = TypeVar("_K")
_V = TypeVar("_V")
_AnyPath = Union[Path, str]

MAX_PARTS: int = ...
MAX_SINGLE_UPLOAD_SIZE: int = 5 * 1024**3
MIN_UPLOAD_CHUNKSIZE: int = ...
logger: Logger = ...
S3_RETRYABLE_DOWNLOAD_ERRORS: Tuple[Type[Exception], ...] = ...

def random_file_extension(num_digits: int = ...) -> str: ...
def signal_not_transferring(
    request: Any, operation_name: str, **kwargs: Any
) -> None: ...
def signal_transferring(request: Any, operation_name: str, **kwargs: Any) -> None: ...
def calculate_num_parts(size: int, part_size: int) -> int: ...
def calculate_range_parameter(
    part_size: int, part_index: int, num_parts: int, total_size: Optional[int] = ...
) -> str: ...
def get_callbacks(
    transfer_future: TransferFuture, callback_type: str
) -> List[Callable[..., Any]]: ...
def invoke_progress_callbacks(
    callbacks: List[Callable[..., Any]], bytes_transferred: int
) -> None: ...
def get_filtered_dict(
    original_dict: Dict[_K, _V], whitelisted_keys: List[str]
) -> Dict[_K, _V]: ...

_CopySource = TypedDict("_CopySource", Bucket=str, Key=str)

class CallArgs:
    bucket: str
    copy_source: _CopySource
    extra_args: Dict[str, Any]
    fileobj: _AnyPath
    key: str
    def __init__(self, **kwargs: Any) -> None: ...

class FunctionContainer:
    def __init__(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -> None: ...
    def __repr__(self) -> str: ...
    def __call__(self) -> Any: ...

class CountCallbackInvoker:
    def __init__(self, callback: Callable[..., Any]) -> None: ...
    @property
    def current_count(self) -> int: ...
    def increment(self) -> None: ...
    def decrement(self) -> None: ...
    def finalize(self) -> None: ...

class OSUtils:
    _MAX_FILENAME_LEN: ClassVar[int] = ...
    def get_file_size(self, filename: _AnyPath) -> int: ...
    def open_file_chunk_reader(
        self,
        filename: _AnyPath,
        start_byte: int,
        size: int,
        callbacks: List[Callable[..., Any]],
    ) -> ReadFileChunk: ...
    def open_file_chunk_reader_from_fileobj(
        self,
        fileobj: _AnyPath,
        chunk_size: int,
        full_file_size: int,
        callbacks: List[Callable[..., Any]],
        close_callbacks: Optional[List[Callable[..., Any]]] = ...,
    ) -> ReadFileChunk: ...
    def open(self, filename: _AnyPath, mode: str) -> Any: ...
    def remove_file(self, filename: _AnyPath) -> None: ...
    def rename_file(
        self, current_filename: _AnyPath, new_filename: _AnyPath
    ) -> None: ...
    @classmethod
    def is_special_file(cls, filename: _AnyPath) -> bool: ...
    def get_temp_filename(self, filename: _AnyPath) -> str: ...
    def allocate(self, filename: _AnyPath, size: int) -> None: ...

class DeferredOpenFile:
    def __init__(
        self, filename, start_byte=..., mode=..., open_function=...
    ) -> None: ...
    @property
    def name(self): ...
    def read(self, amount=...): ...
    def write(self, data): ...
    def seek(self, where): ...
    def tell(self): ...
    def close(self): ...
    def __enter__(self): ...
    def __exit__(self, *args, **kwargs): ...

class ReadFileChunk:
    def __init__(
        self,
        fileobj,
        chunk_size,
        full_file_size,
        callbacks=...,
        enable_callbacks=...,
        close_callbacks=...,
    ) -> None: ...
    @classmethod
    def from_filename(
        cls, filename, start_byte, chunk_size, callbacks=..., enable_callbacks=...
    ): ...
    def read(self, amount=...): ...
    def signal_transferring(self): ...
    def signal_not_transferring(self): ...
    def enable_callback(self): ...
    def disable_callback(self): ...
    def seek(self, where): ...
    def close(self): ...
    def tell(self): ...
    def __len__(self): ...
    def __enter__(self): ...
    def __exit__(self, *args, **kwargs): ...
    def __iter__(self): ...

class StreamReaderProgress:
    def __init__(self, stream, callbacks=...) -> None: ...
    def read(self, *args, **kwargs): ...

class NoResourcesAvailable(Exception): ...

class TaskSemaphore:
    def __init__(self, count) -> None: ...
    def acquire(self, tag, blocking=...): ...
    def release(self, tag, acquire_token): ...

class SlidingWindowSemaphore(TaskSemaphore):
    def __init__(self, count) -> None: ...
    def current_count(self): ...
    def acquire(self, tag, blocking=...): ...
    def release(self, tag, acquire_token): ...

class ChunksizeAdjuster:
    def __init__(self, max_size=..., min_size=..., max_parts=...) -> None: ...
    def adjust_chunksize(self, current_chunksize, file_size=...): ...
